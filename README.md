# Ziggurat
A GUI-based text editor written in zig. Mainly intended as a learning project and ideally skills demo.

The name isn't that meaningful, just a play on zig and the idea of building functionality in solid discrete layers. The hope is that most components are well built and self-sufficient enough to be viable as standalone imports to other projects. 

# Layer 1: Text Engine

This is more or less complete. I have an idea about adding gap buffers in the leaves, but for now performance is lightning fast in tests. 

## Limitations

1. Can perform hundreds of thousands of random edits on files in the 10MB range in under a second. If that's not fast enough for you, look elsewhere. 
2. It makes some assumptions about UTF-8 encoding. There is no guarantee it will work with multi-character bytes. In fact it very probably wont.

## Implementation

Built in layers. Top layer is a [piece table](https://dev.to/_darrenburns/the-piece-table---the-unsung-hero-of-your-text-editor-al8/comments) with one buffer for the original document and another for any edits. In the general case, performance and resources will scale with the number of edits. Second layer is a [rope](https://en.wikipedia.org/wiki/Rope_(data_structure)) implemented as a b-tree. This turns that scaling from O(n) in the edits to O(log n). There's a third layer possible of replacing the piece arrays in each piece with gap buffers for faster local edits, but I'm not exploring that at this time. 

There's a simpler version with just the piece table backed by an array included with the tools. This was a first pass attempt and quite slow, but it's easy to verify correctness and this is used for generating test artifacts. Agreement between the output generated by this reference implementation and the faster versions are how I guarantee correctness. 

## API Reference

`TextEngine` objects expose a public API with 5 methods:

1. `init` - takes an allocator and initial text.
2. `deinit` - destroys the table.
3. `insert` - takes an index corresponding to the location in the working document and a string to insert there.
4. `delete` - takes an index corresponding to the location in the working document and a length of characters to delete.
5. `materialize` - takes an arbitrary writer and materializes the working document into it.

# Layer 2: Testing Harness and Fixture Generation

The build script will output an executable CLI called `test-engine`. Running this with no args will produce some example usage to help get you started. This tool has two uses:

1. Generate test fixtures for verifying correctness and benchmarking the text engine.
2. Actually benchmarking the text engine. 

These functions are accessed via different sets of CLI arguments, and there's a shortcut for running all existing test fixtures as benchmarks in succession. Very handy for profiling different workloads. 

# Roadmap

1. Start writing a GUI! --- exact feature set TBD.
2. More advanced text editor features like undo/redo, copy/paste etc.
3. Maybe more? I don't really have a set end goal for this project. 