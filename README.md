# Ziggurat
A GUI-based text editor written in zig. Mainly intended as a learning project and ideally skills demo.

The name isn't that meaningful, just a play on zig and the idea of building functionality in solid discrete layers. The hope is that most components are well built and self-sufficient enough to be viable as standalone imports to other projects. 

## Layer 1: Text Buffer

This is more or less complete. In release mode, it will perform 100,000 mixed random operations of varying lengths on large files in ~15-20ms. It can materialize full documents in the 10MB range in 5ms. It's highly portable, with no dependencies other than zig itself. You could deploy this on a microcontroller, though I probably wouldn't recommend it since it relies heavily on the heap. 

### Limitations

1. It makes some assumptions about UTF-8 encoding. There is no guarantee it will work with multi-character bytes. In fact it very probably wont.
2. Maximum file size is limited to half of your system's virtual address space. That's 2GB on 32bit systems, irrelevant on 64bit systems. 

### Implementation

Built in layers. Top layer is a [piece table](https://dev.to/_darrenburns/the-piece-table---the-unsung-hero-of-your-text-editor-al8/comments) with one buffer for the original document and another for any edits. In the general case, performance and resources will scale with the number of edits. Second layer is a [rope](https://en.wikipedia.org/wiki/Rope_(data_structure)) implemented as a b-tree. This turns that scaling from O(n) in the edits to O(log n). There's a third layer possible of replacing the piece arrays in each leaf with gap buffers for faster local edits, but I'm not exploring that at this time. 

There's a simpler version with just the piece table backed by an array included with the tools. This was a first pass attempt and comparatively very slow, but it's easy to verify correctness and this is used for generating test artifacts. Agreement between the output generated by this reference implementation and the faster versions are how I guarantee it works properly.  

### API Reference

`TextBuffer` objects expose a public API with 5 methods:

1. `init` - takes an allocator and initial text.
2. `deinit` - destroys the table.
3. `insert` - takes an index corresponding to the location in the working document and a string to insert there.
4. `delete` - takes an index corresponding to the location in the working document and a length of characters to delete.
5. `materialize` - takes an arbitrary writer and materializes the working document into it.

## Layer 2: Testing Harness and Fixture Generation

The build script will output an executable CLI called `test-engine`. Running this with no args will produce some example usage to help get you started. This tool has two uses:

1. Generating test fixtures.
2. Benchmarking the text engine. 

These functions are accessed via different sets of CLI arguments, and there's a shortcut for running all existing test fixtures as benchmarks in succession. Very handy for profiling different workloads. 

## Roadmap

1. Start writing a GUI! --- exact feature set TBD.
2. More advanced text editor features like undo/redo, copy/paste etc.
3. Maybe more? I don't really have a set end goal for this project. 